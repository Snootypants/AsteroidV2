EXECUTION MODE — fix Ship scale and mouse-facing orientation. Output ONE unified diff under `/diffs/` only. Then commit and push.

Goals
- Ship should appear ~the same on-screen size as vanilla (roughly 90–110px tall on 1080p; adjustably constant).
- Ship nose must point TOWARD the mouse cursor.
- Keep orthographic camera; make pixel→world mapping predictable.

Scope
- `/AsteroidsV2/reactShell/src/game/GameCanvas.tsx`
- `/AsteroidsV2/reactShell/src/game/entities/Ship.ts`

Tasks

1) Camera: pixel-perfect orthographic mapping
- In `GameCanvas.tsx`, create/update the ORTHO camera so 1 world unit = 1 CSS pixel:
  ```ts
  function makeOrthoCamera(w: number, h: number) {
    const halfW = w / 2, halfH = h / 2;
    const cam = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, 0.1, 1000);
    cam.position.set(0, 0, 10);
    cam.lookAt(0, 0, 0);
    return cam;
  }

	•	Use this on init and in the resize handler so the frustum tracks the canvas width/height exactly.
	•	Update any screen→world conversion to assume the above mapping.

	2.	Ship orientation: face the mouse

	•	In Ship.ts, when aiming:

const angle = Math.atan2(target.y - pos.y, target.x - pos.x);
// Choose a single rotation offset based on how the sprite is drawn.
// If the sprite's nose points "up" (+Y), use -Math.PI/2. If it points "right" (+X), use 0.
const ROTATION_OFFSET = -Math.PI / 2;
this.object.rotation.z = angle + ROTATION_OFFSET;


	•	Verify quickly by moving the mouse around: the ship nose should track the cursor. If it’s still 90° off, switch the offset to +Math.PI/2; if 180° off, use Math.PI.

	3.	Ship visual scale: set via desired pixel height

	•	Add a constant in Ship.ts:

const SHIP_DESIRED_PX = 100; // tweak 90–110 for parity with vanilla screenshot


	•	After the texture/material is ready and the this.object (Sprite or Mesh) has a natural size, set scale so its on-screen height ≈ SHIP_DESIRED_PX in world units (since 1 world unit = 1 pixel after step 1):
	•	If you use a THREE.Sprite:

const imgH = texture.image?.height ?? SHIP_DESIRED_PX;
const scale = SHIP_DESIRED_PX / imgH;
this.object.scale.set(
  texture.image?.width ? texture.image.width * scale : SHIP_DESIRED_PX,
  SHIP_DESIRED_PX,
  1
);


	•	If you use a mesh (Plane/Geometry):
	•	Compute its current bounding box height geomH and set this.object.scale.multiplyScalar(SHIP_DESIRED_PX / geomH).

	•	Recompute the ship scale on window resize only if your implementation depends on DPR; with the 1:1 ortho camera and DPR-aware renderer sizing, a single scale set is enough.

	4.	Keep behavior intact

	•	Do NOT change physics, thrust, friction, wrapping, or PostFX.
	•	Camera follow logic may remain, but ensure it doesn’t rescale the ship.

Deliverable
	•	Print ONE timestamped unified diff under /diffs/ containing ONLY the above edits to GameCanvas.tsx and Ship.ts. Full patch, no truncation/summaries.
	•	After printing, commit and push.

