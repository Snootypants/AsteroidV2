diff --git a/reactShell/src/game/GameCanvas.tsx b/reactShell/src/game/GameCanvas.tsx
index 9bd0dc1..c39d0a4 100644
--- a/reactShell/src/game/GameCanvas.tsx
+++ b/reactShell/src/game/GameCanvas.tsx
@@ -5,6 +5,7 @@ import { createComposer, resize, render } from './render/PostFX'
 import { Input } from './Input'
 import { Ship } from './entities/Ship'
 import { BulletManager } from './systems/BulletManager'
+import { Spawning } from './systems/Spawning'
 import { DevStats } from '../ui/DevPanel'
 import { DebugBus } from '../dev/DebugBus'
 
@@ -33,6 +34,7 @@ export default function GameCanvas({ onStats }: GameCanvasProps) {
   const shipRef = useRef<Ship | null>(null)
   const inputRef = useRef<Input | null>(null)
   const bulletManagerRef = useRef<BulletManager | null>(null)
+  const spawningRef = useRef<Spawning | null>(null)
 
   useEffect(() => {
     if (!canvasRef.current) return
@@ -49,10 +51,15 @@ export default function GameCanvas({ onStats }: GameCanvasProps) {
     const input = new Input()
     const bulletManager = new BulletManager(scene)
     const ship = new Ship(scene, bulletManager)
+    const spawning = new Spawning(scene)
     
     shipRef.current = ship
     inputRef.current = input
     bulletManagerRef.current = bulletManager
+    spawningRef.current = spawning
+    
+    // Initialize level with asteroids (5-8 for testing)
+    spawning.initializeLevel()
     
     // Dev panel greeting
     DebugBus.push('info', 'DevPanel ready')
@@ -123,6 +130,9 @@ export default function GameCanvas({ onStats }: GameCanvasProps) {
       // Update bullets
       bulletManager.update(dt)
       
+      // Update asteroids
+      spawning.update(dt)
+      
       // Follow ship with camera (simple following)
       const shipPos = ship.getPosition()
       camera.position.x = shipPos.x
@@ -140,7 +150,7 @@ export default function GameCanvas({ onStats }: GameCanvasProps) {
           fps: avgFps,
           entities: { 
             ships: 1, 
-            asteroids: 0, 
+            asteroids: spawning.getAsteroidCount(), 
             bullets: bulletManager.getActiveCount(), 
             other: 0 
           },
diff --git a/reactShell/src/game/entities/Asteroid.ts b/reactShell/src/game/entities/Asteroid.ts
index d22b4c8..3757b58 100644
--- a/reactShell/src/game/entities/Asteroid.ts
+++ b/reactShell/src/game/entities/Asteroid.ts
@@ -1,2 +1,190 @@
 // Asteroid.ts - Asteroid variants
-export class Asteroid {}
\ No newline at end of file
+import * as THREE from 'three'
+
+// Constants from vanilla (lines 28-33)
+const ASTEROIDS = {
+  large: { r: 6, score: 20, next: 'medium', count: 2 },
+  medium: { r: 3.5, score: 50, next: 'small', count: 2 },
+  small: { r: 2.0, score: 100, next: null, count: 0 },
+  baseSpeed: 8,
+}
+
+const WORLD = {
+  width: 750,
+  height: 498,
+}
+
+// Ore types with colors and probabilities (from lines 819-825)
+export type OreType = 'iron' | 'gold' | 'platinum' | 'adamantium'
+export type AsteroidSize = 'large' | 'medium' | 'small'
+
+const ORE_COLORS: Record<OreType, number> = {
+  iron: 0x808080,      // Gray
+  gold: 0xFFD700,      // Gold/Yellow
+  platinum: 0xC0C0C0,  // Silver
+  adamantium: 0x9400D3 // Purple
+}
+
+// Ore type probability function (lines 819-825)
+export function chooseOreType(): OreType {
+  const r = Math.random()
+  if (r > 0.995) return 'adamantium'  // 0.5%
+  if (r > 0.975) return 'platinum'    // 2.5%
+  if (r > 0.9) return 'gold'          // 7%
+  return 'iron'                       // 90%
+}
+
+export class Asteroid {
+  object: THREE.Mesh
+  private velocity = new THREE.Vector2(0, 0)
+  private size: AsteroidSize
+  private oreType: OreType
+  private rotationSpeed: number
+
+  constructor(scene: THREE.Scene, size: AsteroidSize, oreType: OreType, x = 0, y = 0) {
+    this.size = size
+    this.oreType = oreType
+    this.rotationSpeed = (Math.random() - 0.5) * 2 // Random rotation speed
+    
+    this.object = this.createAsteroidMesh()
+    this.object.position.set(x, y, 0)
+    
+    // Set random velocity based on baseSpeed
+    const angle = Math.random() * Math.PI * 2
+    const speed = ASTEROIDS.baseSpeed + (Math.random() - 0.5) * 4 // baseSpeed ± 2
+    this.velocity.set(
+      Math.cos(angle) * speed,
+      Math.sin(angle) * speed
+    )
+    
+    // Store metadata
+    this.object.userData = {
+      kind: 'asteroid',
+      size: this.size,
+      oreType: this.oreType,
+      radius: ASTEROIDS[size].r,
+      score: ASTEROIDS[size].score,
+      vx: this.velocity.x,
+      vy: this.velocity.y,
+      alive: true
+    }
+    
+    scene.add(this.object)
+  }
+
+  private createAsteroidMesh(): THREE.Mesh {
+    const radius = ASTEROIDS[this.size].r
+    const geometry = new THREE.SphereGeometry(radius, 8, 6) // Low poly for retro feel
+    const material = new THREE.MeshBasicMaterial({ 
+      color: ORE_COLORS[this.oreType],
+      wireframe: false 
+    })
+    
+    return new THREE.Mesh(geometry, material)
+  }
+
+  update(dt: number): void {
+    if (!this.object.userData.alive) return
+    
+    // Update position
+    this.object.position.x += this.velocity.x * dt
+    this.object.position.y += this.velocity.y * dt
+    
+    // World wrapping at ±375×±249
+    const halfWidth = WORLD.width / 2  // ±375
+    const halfHeight = WORLD.height / 2 // ±249
+    
+    if (this.object.position.x > halfWidth) {
+      this.object.position.x = -halfWidth
+    } else if (this.object.position.x < -halfWidth) {
+      this.object.position.x = halfWidth
+    }
+    
+    if (this.object.position.y > halfHeight) {
+      this.object.position.y = -halfHeight
+    } else if (this.object.position.y < -halfHeight) {
+      this.object.position.y = halfHeight
+    }
+    
+    // Rotation
+    this.object.rotation.z += this.rotationSpeed * dt
+    
+    // Update userData velocity for debugging
+    this.object.userData.vx = this.velocity.x
+    this.object.userData.vy = this.velocity.y
+  }
+
+  // Split asteroid into smaller pieces
+  split(scene: THREE.Scene): Asteroid[] {
+    if (!this.object.userData.alive) return []
+    
+    const config = ASTEROIDS[this.size]
+    if (!config.next || config.count === 0) {
+      return [] // Small asteroids don't split
+    }
+    
+    const newSize = config.next as AsteroidSize
+    const newAsteroids: Asteroid[] = []
+    
+    for (let i = 0; i < config.count; i++) {
+      // Create new asteroid at current position with slight offset
+      const offsetX = (Math.random() - 0.5) * 4
+      const offsetY = (Math.random() - 0.5) * 4
+      
+      const newAsteroid = new Asteroid(
+        scene, 
+        newSize, 
+        this.oreType, // Same ore type as parent
+        this.object.position.x + offsetX,
+        this.object.position.y + offsetY
+      )
+      
+      newAsteroids.push(newAsteroid)
+    }
+    
+    return newAsteroids
+  }
+
+  // Handle damage/collision
+  takeDamage(): boolean {
+    this.object.userData.alive = false
+    return true
+  }
+
+  // Cleanup
+  destroy(scene: THREE.Scene): void {
+    this.object.userData.alive = false
+    scene.remove(this.object)
+    this.object.geometry.dispose()
+    if (Array.isArray(this.object.material)) {
+      this.object.material.forEach((m: any) => m.dispose())
+    } else {
+      (this.object.material as any).dispose()
+    }
+  }
+
+  // Getters
+  getPosition(): THREE.Vector2 {
+    return new THREE.Vector2(this.object.position.x, this.object.position.y)
+  }
+
+  getRadius(): number {
+    return ASTEROIDS[this.size].r
+  }
+
+  getScore(): number {
+    return ASTEROIDS[this.size].score
+  }
+
+  getSize(): AsteroidSize {
+    return this.size
+  }
+
+  getOreType(): OreType {
+    return this.oreType
+  }
+
+  isAlive(): boolean {
+    return this.object.userData.alive
+  }
+}
\ No newline at end of file
diff --git a/reactShell/src/game/systems/Spawning.ts b/reactShell/src/game/systems/Spawning.ts
index 7f55d2d..b489630 100644
--- a/reactShell/src/game/systems/Spawning.ts
+++ b/reactShell/src/game/systems/Spawning.ts
@@ -1,2 +1,147 @@
 // Spawning.ts - Wave generation, enemy spawning
-export class Spawning {}
\ No newline at end of file
+import * as THREE from 'three'
+import { Asteroid, chooseOreType, type AsteroidSize, type OreType } from '../entities/Asteroid'
+
+const WORLD = {
+  width: 750,
+  height: 498,
+}
+
+export class Spawning {
+  private scene: THREE.Scene
+  private asteroids: Asteroid[] = []
+
+  constructor(scene: THREE.Scene) {
+    this.scene = scene
+  }
+
+  // Spawn a single asteroid at a random position
+  spawnAsteroid(size: AsteroidSize = 'large', oreType?: OreType): Asteroid {
+    // Choose random ore type if not specified
+    const finalOreType = oreType || chooseOreType()
+    
+    // Random position at world edges (avoid spawning on player)
+    const edge = Math.floor(Math.random() * 4) // 0=top, 1=right, 2=bottom, 3=left
+    let x: number, y: number
+    
+    const halfWidth = WORLD.width / 2   // ±375
+    const halfHeight = WORLD.height / 2 // ±249
+    const margin = 50 // Spawn outside visible area
+    
+    switch (edge) {
+      case 0: // Top
+        x = (Math.random() - 0.5) * WORLD.width
+        y = halfHeight + margin
+        break
+      case 1: // Right
+        x = halfWidth + margin
+        y = (Math.random() - 0.5) * WORLD.height
+        break
+      case 2: // Bottom
+        x = (Math.random() - 0.5) * WORLD.width
+        y = -halfHeight - margin
+        break
+      case 3: // Left
+      default:
+        x = -halfWidth - margin
+        y = (Math.random() - 0.5) * WORLD.height
+        break
+    }
+    
+    const asteroid = new Asteroid(this.scene, size, finalOreType, x, y)
+    this.asteroids.push(asteroid)
+    
+    return asteroid
+  }
+
+  // Spawn multiple asteroids
+  spawnAsteroids(count: number, size: AsteroidSize = 'large'): Asteroid[] {
+    const spawned: Asteroid[] = []
+    
+    for (let i = 0; i < count; i++) {
+      const asteroid = this.spawnAsteroid(size)
+      spawned.push(asteroid)
+    }
+    
+    return spawned
+  }
+
+  // Initialize level with starting asteroids (5-8 for testing)
+  initializeLevel(): void {
+    const count = 5 + Math.floor(Math.random() * 4) // 5-8 asteroids
+    this.spawnAsteroids(count, 'large')
+  }
+
+  // Add asteroid to tracking (for split asteroids)
+  addAsteroid(asteroid: Asteroid): void {
+    this.asteroids.push(asteroid)
+  }
+
+  // Remove asteroid from tracking
+  removeAsteroid(asteroid: Asteroid): void {
+    const index = this.asteroids.indexOf(asteroid)
+    if (index !== -1) {
+      this.asteroids.splice(index, 1)
+      asteroid.destroy(this.scene)
+    }
+  }
+
+  // Update all asteroids
+  update(dt: number): void {
+    // Update all asteroids
+    for (const asteroid of this.asteroids) {
+      if (asteroid.isAlive()) {
+        asteroid.update(dt)
+      }
+    }
+    
+    // Clean up dead asteroids
+    this.asteroids = this.asteroids.filter(asteroid => {
+      if (!asteroid.isAlive()) {
+        asteroid.destroy(this.scene)
+        return false
+      }
+      return true
+    })
+  }
+
+  // Split asteroid and manage the resulting pieces
+  splitAsteroid(asteroid: Asteroid): Asteroid[] {
+    if (!asteroid.isAlive()) return []
+    
+    const newAsteroids = asteroid.split(this.scene)
+    
+    // Add new asteroids to tracking
+    for (const newAsteroid of newAsteroids) {
+      this.addAsteroid(newAsteroid)
+    }
+    
+    // Remove the original asteroid
+    this.removeAsteroid(asteroid)
+    
+    return newAsteroids
+  }
+
+  // Get all active asteroids
+  getAsteroids(): Asteroid[] {
+    return this.asteroids.filter(asteroid => asteroid.isAlive())
+  }
+
+  // Get asteroid count
+  getAsteroidCount(): number {
+    return this.getAsteroids().length
+  }
+
+  // Check if level is clear (no asteroids left)
+  isLevelClear(): boolean {
+    return this.getAsteroidCount() === 0
+  }
+
+  // Clear all asteroids
+  clearAll(): void {
+    for (const asteroid of this.asteroids) {
+      asteroid.destroy(this.scene)
+    }
+    this.asteroids = []
+  }
+}
\ No newline at end of file
