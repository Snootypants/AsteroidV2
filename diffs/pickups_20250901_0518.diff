diff --git a/docs/prompts/8.md b/docs/prompts/8.md
new file mode 100644
index 0000000..45649c9
--- /dev/null
+++ b/docs/prompts/8.md
@@ -0,0 +1,21 @@
+> APPROVAL: Block 10 (Upgrades System & Picker UI) is complete and validated against acceptance criteria.  
+Proceed with Block 11: Currency Pickups & Magnetism.  
+
+Use the execution prompt already defined in the plan for Block 11.  
+Implementation details to cover:  
+- NEW Pickup.ts entity with floating animation, TTL, and collection radius  
+- Spawn currency drops when asteroids are destroyed, based on ore type drop rates (gold=27%, platinum=60%, adamantium=40%)  
+- Magnetism: ship attracts pickups within radius (base + upgrade scaling)  
+- Auto-collect after 10s if not picked up  
+- Update GameState.currency on collection  
+- Integrate pickup rendering into GameCanvas update loop  
+
+Acceptance criteria:  
+- ✅ Destroying a gold asteroid has ~27% chance to drop gold pickup  
+- ✅ Platinum and adamantium pickups spawn at correct probabilities  
+- ✅ Pickups float slightly, auto-collect after 10s  
+- ✅ Ship auto-collects pickups within magnet radius  
+- ✅ Currency totals update live in HUD panel  
+- ✅ No performance regressions  
+
+Output: Single unified diff under `/diffs/pickups_[timestamp].diff` and commit the changes.  
\ No newline at end of file
diff --git a/reactShell/src/game/GameCanvas.tsx b/reactShell/src/game/GameCanvas.tsx
index 2c502d4..7c8c7b7 100644
--- a/reactShell/src/game/GameCanvas.tsx
+++ b/reactShell/src/game/GameCanvas.tsx
@@ -9,6 +9,7 @@ import { Spawning } from './systems/Spawning'
 import { CollisionManager } from './systems/Collision'
 import { ParticleManager } from './entities/Particles'
 import { DebrisManager } from './entities/Debris'
+import { PickupManager } from './systems/PickupManager'
 import { GameState, selectScore, selectWave, selectCombo, selectCurrency, selectUpgrades } from './GameState'
 import { createEnemyBullets } from './systems/EnemyBullets'
 import { DevStats } from '../ui/DevPanel'
@@ -68,6 +69,7 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
   const collisionManagerRef = useRef<CollisionManager | null>(null)
   const particleManagerRef = useRef<ParticleManager | null>(null)
   const debrisManagerRef = useRef<DebrisManager | null>(null)
+  const pickupManagerRef = useRef<PickupManager | null>(null)
   const gameStateRef = useRef<GameState | null>(null)
   const enemyBulletsRef = useRef<any>(null)
 
@@ -90,11 +92,13 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
     const spawning = new Spawning(scene)
     const particleManager = new ParticleManager(scene)
     const debrisManager = new DebrisManager(scene)
+    const pickupManager = new PickupManager(scene, gameState)
     const enemyBullets = createEnemyBullets(scene)
     const collisionManager = new CollisionManager(bulletManager, spawning, ship, gameState, scene, particleManager, debrisManager)
     
-    // Connect enemy bullets to collision manager
+    // Connect enemy bullets and pickup manager to collision manager
     collisionManager.setEnemyBullets(enemyBullets)
+    collisionManager.setPickupManager(pickupManager)
     
     shipRef.current = ship
     inputRef.current = input
@@ -103,6 +107,7 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
     collisionManagerRef.current = collisionManager
     particleManagerRef.current = particleManager
     debrisManagerRef.current = debrisManager
+    pickupManagerRef.current = pickupManager
     gameStateRef.current = gameState
     enemyBulletsRef.current = enemyBullets
     
@@ -206,6 +211,12 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
       particleManager.update(dt)
       debrisManagerRef.current!.update(dt)
       
+      // Update pickups (magnetic collection and timeout)
+      const shipPos = ship.getPosition()
+      const mods = gameState.getMods()
+      const magnetRadius = 3 + mods.magnetRadius // Base radius + upgrade scaling
+      pickupManagerRef.current!.update(dt, shipPos, magnetRadius)
+      
       // Update collision detection (effects now handled internally)
       collisionManager.update(dt)
       
@@ -252,6 +263,7 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
               bullets: bulletManager.getActiveCount(), 
               particles: particleManager.getActiveCount(),
               debris: debrisManagerRef.current!.getActiveCount(),
+              pickups: pickupManagerRef.current!.getActiveCount(),
               other: spawning.getHunterCount() + enemyBullets.getActiveCount() 
             },
             score: gameState.getScore(),
diff --git a/reactShell/src/game/GameState.ts b/reactShell/src/game/GameState.ts
index 22804ff..0b09d30 100644
--- a/reactShell/src/game/GameState.ts
+++ b/reactShell/src/game/GameState.ts
@@ -236,6 +236,23 @@ export class GameState {
     this.takenUpgrades.add(upgradeId)
   }
 
+  // Currency management
+  getCurrency() {
+    return this.currency
+  }
+
+  addCurrency(type: 'salvage' | 'gold' | 'platinum' | 'adamantium', amount: number): void {
+    this.currency[type] += amount
+  }
+
+  spendCurrency(type: 'salvage' | 'gold' | 'platinum' | 'adamantium', amount: number): boolean {
+    if (this.currency[type] >= amount) {
+      this.currency[type] -= amount
+      return true
+    }
+    return false
+  }
+
   // Get full state snapshot for debugging
   getState() {
     return {
diff --git a/reactShell/src/game/entities/Pickup.ts b/reactShell/src/game/entities/Pickup.ts
new file mode 100644
index 0000000..6fb8d50
--- /dev/null
+++ b/reactShell/src/game/entities/Pickup.ts
@@ -0,0 +1,172 @@
+// Pickup.ts - Currency pickup entities
+import * as THREE from 'three'
+
+export type CurrencyType = 'salvage' | 'gold' | 'platinum' | 'adamantium'
+
+// Currency pickup colors and properties
+const CURRENCY_COLORS: Record<CurrencyType, number> = {
+  salvage: 0x808080,    // Gray
+  gold: 0xFFD700,       // Yellow/Gold
+  platinum: 0xC0C0C0,   // Silver
+  adamantium: 0x9400D3  // Purple
+}
+
+// Pickup constants
+const PICKUP_CONFIG = {
+  size: 1.2,           // Base pickup size
+  floatHeight: 8,      // Height of floating animation
+  floatSpeed: 2.5,     // Speed of floating animation
+  ttl: 10.0,           // Auto-collect timeout in seconds
+  magneticSpeed: 120,  // Speed when attracted to ship
+  collectionRadius: 2  // Direct collection radius
+}
+
+export class Pickup {
+  object: THREE.Mesh
+  private currencyType: CurrencyType
+  private amount: number
+  private lifetime: number = 0
+  private floatOffset: number
+  private isBeingAttracted: boolean = false
+  private velocity = new THREE.Vector2(0, 0)
+
+  constructor(scene: THREE.Scene, currencyType: CurrencyType, amount: number, x: number, y: number) {
+    this.currencyType = currencyType
+    this.amount = amount
+    this.floatOffset = Math.random() * Math.PI * 2 // Random float phase
+    
+    this.object = this.createPickupMesh()
+    this.object.position.set(x, y, 0)
+    
+    // Store metadata
+    this.object.userData = {
+      kind: 'pickup',
+      currencyType: this.currencyType,
+      amount: this.amount,
+      alive: true
+    }
+    
+    scene.add(this.object)
+  }
+
+  private createPickupMesh(): THREE.Mesh {
+    // Create a small cube with slightly rounded edges for visual appeal
+    const geometry = new THREE.BoxGeometry(PICKUP_CONFIG.size, PICKUP_CONFIG.size, PICKUP_CONFIG.size)
+    const material = new THREE.MeshBasicMaterial({ 
+      color: CURRENCY_COLORS[this.currencyType],
+      transparent: true,
+      opacity: 0.9
+    })
+    
+    return new THREE.Mesh(geometry, material)
+  }
+
+  update(dt: number, shipPosition?: THREE.Vector2, magnetRadius: number = 0): boolean {
+    if (!this.object.userData.alive) return false
+    
+    this.lifetime += dt
+    
+    // Auto-collect timeout
+    if (this.lifetime >= PICKUP_CONFIG.ttl) {
+      this.object.userData.alive = false
+      return false
+    }
+    
+    // Check for magnetic attraction
+    if (shipPosition && magnetRadius > 0) {
+      const pickupPos = new THREE.Vector2(this.object.position.x, this.object.position.y)
+      const distanceToShip = pickupPos.distanceTo(shipPosition)
+      
+      if (distanceToShip <= magnetRadius) {
+        this.isBeingAttracted = true
+        
+        // Move towards ship
+        const direction = shipPosition.clone().sub(pickupPos).normalize()
+        this.velocity = direction.multiplyScalar(PICKUP_CONFIG.magneticSpeed)
+        
+        // Update position based on magnetic attraction
+        this.object.position.x += this.velocity.x * dt
+        this.object.position.y += this.velocity.y * dt
+      } else {
+        this.isBeingAttracted = false
+        this.velocity.set(0, 0)
+      }
+    }
+    
+    // Floating animation (only when not being attracted)
+    if (!this.isBeingAttracted) {
+      const floatY = Math.sin(this.lifetime * PICKUP_CONFIG.floatSpeed + this.floatOffset) * 0.5
+      this.object.position.y += floatY * dt * PICKUP_CONFIG.floatHeight
+    }
+    
+    // Gentle rotation for visual appeal
+    this.object.rotation.y += dt * 2
+    this.object.rotation.x += dt * 1.5
+    
+    // Fade effect as TTL approaches
+    const fadeStart = PICKUP_CONFIG.ttl * 0.7 // Start fading at 70% of TTL
+    if (this.lifetime >= fadeStart) {
+      const fadeProgress = (this.lifetime - fadeStart) / (PICKUP_CONFIG.ttl - fadeStart)
+      const opacity = 0.9 * (1 - fadeProgress)
+      ;(this.object.material as THREE.MeshBasicMaterial).opacity = Math.max(opacity, 0.1)
+    }
+    
+    return true // Still alive
+  }
+
+  // Check if pickup can be collected by ship
+  canCollect(shipPosition: THREE.Vector2): boolean {
+    if (!this.object.userData.alive) return false
+    
+    const pickupPos = new THREE.Vector2(this.object.position.x, this.object.position.y)
+    const distance = pickupPos.distanceTo(shipPosition)
+    
+    return distance <= PICKUP_CONFIG.collectionRadius
+  }
+
+  // Collect the pickup
+  collect(): { type: CurrencyType, amount: number } {
+    this.object.userData.alive = false
+    return {
+      type: this.currencyType,
+      amount: this.amount
+    }
+  }
+
+  // Cleanup
+  destroy(scene: THREE.Scene): void {
+    this.object.userData.alive = false
+    scene.remove(this.object)
+    this.object.geometry.dispose()
+    if (Array.isArray(this.object.material)) {
+      this.object.material.forEach((m: any) => m.dispose())
+    } else {
+      (this.object.material as any).dispose()
+    }
+  }
+
+  // Getters
+  getPosition(): THREE.Vector2 {
+    return new THREE.Vector2(this.object.position.x, this.object.position.y)
+  }
+
+  getCurrencyType(): CurrencyType {
+    return this.currencyType
+  }
+
+  getAmount(): number {
+    return this.amount
+  }
+
+  isAlive(): boolean {
+    return this.object.userData.alive
+  }
+
+  getLifetime(): number {
+    return this.lifetime
+  }
+
+  getTTL(): number {
+    return PICKUP_CONFIG.ttl
+  }
+}
\ No newline at end of file
diff --git a/reactShell/src/game/systems/Collision.ts b/reactShell/src/game/systems/Collision.ts
index 4e60bc1..35ac2fa 100644
--- a/reactShell/src/game/systems/Collision.ts
+++ b/reactShell/src/game/systems/Collision.ts
@@ -8,6 +8,7 @@ import type { Spawning } from './Spawning'
 import type { GameState } from '../GameState'
 import type { ParticleManager } from '../entities/Particles'
 import type { DebrisManager } from '../entities/Debris'
+import type { PickupManager } from './PickupManager'
 
 export interface CollisionEvent {
   type: 'bullet-asteroid' | 'ship-asteroid' | 'enemy-bullet-ship'
@@ -24,6 +25,7 @@ export class CollisionManager {
   private scene: THREE.Scene
   private particleManager: ParticleManager
   private debrisManager: DebrisManager
+  private pickupManager: PickupManager | null = null
   private enemyBullets: any // EnemyBullets system will be injected
   
   constructor(
@@ -42,6 +44,7 @@ export class CollisionManager {
     this.scene = scene
     this.particleManager = particleManager
     this.debrisManager = debrisManager
+    this.pickupManager = null
     this.enemyBullets = null
   }
 
@@ -50,6 +53,11 @@ export class CollisionManager {
     this.enemyBullets = enemyBullets
   }
 
+  // Set pickup manager (will be called from GameCanvas)
+  setPickupManager(pickupManager: PickupManager): void {
+    this.pickupManager = pickupManager
+  }
+
   // Main collision detection method
   update(dt: number): void {
     const events: CollisionEvent[] = []
@@ -165,6 +173,7 @@ export class CollisionManager {
     const position = asteroid.getPosition()
     const size = asteroid.getSize()
     const score = asteroid.getScore()
+    const oreType = asteroid.getOreType()
     
     // Destroy bullet
     bullet.expire()
@@ -175,6 +184,11 @@ export class CollisionManager {
     // Add score
     this.gameState.addScore(score)
     
+    // Spawn pickups based on ore type (if pickup manager is available)
+    if (this.pickupManager) {
+      this.pickupManager.spawnPickupsForAsteroid(position, oreType)
+    }
+    
     // Split asteroid if applicable
     const newAsteroids = this.spawning.splitAsteroid(asteroid)
     
diff --git a/reactShell/src/game/systems/PickupManager.ts b/reactShell/src/game/systems/PickupManager.ts
new file mode 100644
index 0000000..6c36f95
--- /dev/null
+++ b/reactShell/src/game/systems/PickupManager.ts
@@ -0,0 +1,178 @@
+// PickupManager.ts - Pickup system with object pooling
+import * as THREE from 'three'
+import { Pickup, type CurrencyType } from '../entities/Pickup'
+import type { GameState } from '../GameState'
+
+// Drop rates from vanilla analysis
+const DROP_RATES = {
+  gold: 0.27,        // 27% chance for gold ore asteroids
+  platinum: 0.60,    // 60% chance for platinum ore asteroids  
+  adamantium: 0.40,  // 40% chance for adamantium ore asteroids
+  salvage: 1.00      // 100% chance for all asteroids
+}
+
+// Currency amounts per pickup
+const CURRENCY_AMOUNTS = {
+  salvage: 1,     // Base currency
+  gold: 3,        // More valuable
+  platinum: 8,    // Much more valuable
+  adamantium: 20  // Most valuable
+}
+
+export class PickupManager {
+  private scene: THREE.Scene
+  private gameState: GameState
+  private activePickups: Pickup[] = []
+  private pickupPool: Pickup[] = [] // Object pool for performance
+  private maxPoolSize: number = 50
+
+  constructor(scene: THREE.Scene, gameState: GameState) {
+    this.scene = scene
+    this.gameState = gameState
+  }
+
+  // Spawn pickup at asteroid destruction location
+  spawnPickup(position: THREE.Vector2, currencyType: CurrencyType, amount?: number): Pickup | null {
+    // Use default amount if not specified
+    const finalAmount = amount || CURRENCY_AMOUNTS[currencyType]
+    
+    // Try to get pickup from pool
+    let pickup = this.pickupPool.pop()
+    
+    if (pickup) {
+      // Reuse pooled pickup
+      pickup.destroy(this.scene) // Clean up old state
+      pickup = new Pickup(this.scene, currencyType, finalAmount, position.x, position.y)
+    } else {
+      // Create new pickup
+      pickup = new Pickup(this.scene, currencyType, finalAmount, position.x, position.y)
+    }
+    
+    this.activePickups.push(pickup)
+    return pickup
+  }
+
+  // Spawn pickups based on asteroid ore type (handles drop rate logic)
+  spawnPickupsForAsteroid(position: THREE.Vector2, oreType: 'iron' | 'gold' | 'platinum' | 'adamantium'): void {
+    // Always spawn salvage
+    this.spawnPickup(position, 'salvage')
+    
+    // Apply ore-specific drop rates for premium currencies
+    let premiumCurrency: CurrencyType | null = null
+    let dropRate = 0
+    
+    switch (oreType) {
+      case 'gold':
+        premiumCurrency = 'gold'
+        dropRate = DROP_RATES.gold
+        break
+      case 'platinum':
+        premiumCurrency = 'platinum'
+        dropRate = DROP_RATES.platinum
+        break
+      case 'adamantium':
+        premiumCurrency = 'adamantium'
+        dropRate = DROP_RATES.adamantium
+        break
+      case 'iron':
+      default:
+        // Iron ore only drops salvage
+        break
+    }
+    
+    // Roll for premium currency drop
+    if (premiumCurrency && Math.random() < dropRate) {
+      // Add slight position offset to avoid overlap
+      const offsetPosition = position.clone().add(new THREE.Vector2(
+        (Math.random() - 0.5) * 4,
+        (Math.random() - 0.5) * 4
+      ))
+      this.spawnPickup(offsetPosition, premiumCurrency)
+    }
+  }
+
+  // Update all pickups
+  update(dt: number, shipPosition: THREE.Vector2, magnetRadius: number): void {
+    // Update all active pickups
+    for (let i = this.activePickups.length - 1; i >= 0; i--) {
+      const pickup = this.activePickups[i]
+      
+      // Update pickup (returns false if expired)
+      const stillAlive = pickup.update(dt, shipPosition, magnetRadius)
+      
+      if (!stillAlive || !pickup.isAlive()) {
+        // Remove from active list
+        this.activePickups.splice(i, 1)
+        
+        // Return to pool if pool isn't full
+        if (this.pickupPool.length < this.maxPoolSize) {
+          this.pickupPool.push(pickup)
+        } else {
+          // Pool is full, destroy completely
+          pickup.destroy(this.scene)
+        }
+        continue
+      }
+      
+      // Check for collection
+      if (pickup.canCollect(shipPosition)) {
+        const collected = pickup.collect()
+        this.addCurrencyToGameState(collected.type, collected.amount)
+        
+        // Remove from active list
+        this.activePickups.splice(i, 1)
+        
+        // Return to pool
+        if (this.pickupPool.length < this.maxPoolSize) {
+          this.pickupPool.push(pickup)
+        } else {
+          pickup.destroy(this.scene)
+        }
+      }
+    }
+  }
+
+  // Add collected currency to game state
+  private addCurrencyToGameState(currencyType: CurrencyType, amount: number): void {
+    this.gameState.addCurrency(currencyType, amount)
+  }
+
+  // Get all active pickups
+  getActivePickups(): Pickup[] {
+    return this.activePickups.filter(pickup => pickup.isAlive())
+  }
+
+  // Get active pickup count
+  getActiveCount(): number {
+    return this.getActivePickups().length
+  }
+
+  // Get total pickup count including pooled
+  getTotalCount(): number {
+    return this.activePickups.length + this.pickupPool.length
+  }
+
+  // Clear all pickups (for level transitions)
+  clearAll(): void {
+    // Destroy all active pickups
+    for (const pickup of this.activePickups) {
+      pickup.destroy(this.scene)
+    }
+    this.activePickups = []
+    
+    // Destroy all pooled pickups
+    for (const pickup of this.pickupPool) {
+      pickup.destroy(this.scene)
+    }
+    this.pickupPool = []
+  }
+
+  // Debug info
+  getDebugInfo() {
+    return {
+      active: this.activePickups.length,
+      pooled: this.pickupPool.length,
+      total: this.getTotalCount()
+    }
+  }
+}
\ No newline at end of file
diff --git a/reactShell/src/ui/DevPanel.tsx b/reactShell/src/ui/DevPanel.tsx
index 8c2b909..080f1c0 100644
--- a/reactShell/src/ui/DevPanel.tsx
+++ b/reactShell/src/ui/DevPanel.tsx
@@ -3,7 +3,7 @@ import { DebugBus, LogEntry } from '../dev/DebugBus'
 
 export type DevStats = {
   fps: number
-  entities: { ships: number; asteroids: number; bullets: number; particles?: number; debris?: number; other: number }
+  entities: { ships: number; asteroids: number; bullets: number; particles?: number; debris?: number; pickups?: number; other: number }
   score?: number
   wave?: number
   ship?: { x: number; y: number; vx: number; vy: number; angleDeg: number; pxHeight: number }
@@ -63,6 +63,7 @@ export function DevPanel({ visible, stats }: DevPanelProps): JSX.Element | null
             Bullets:{stats.entities.bullets}
             {stats.entities.particles !== undefined && ` Particles:${stats.entities.particles}`}
             {stats.entities.debris !== undefined && ` Debris:${stats.entities.debris}`}
+            {stats.entities.pickups !== undefined && ` Pickups:${stats.entities.pickups}`}
             {stats.entities.other > 0 && ` Other:${stats.entities.other}`}
           </span>
         </div>
