diff --git a/diffs/startscreen_complete_20250901_0115.diff b/diffs/startscreen_complete_20250901_0115.diff
new file mode 100644
index 0000000..93adb56
--- /dev/null
+++ b/diffs/startscreen_complete_20250901_0115.diff
@@ -0,0 +1,184 @@
+diff --git a/diffs/startscreen_20250901_0109.diff b/diffs/startscreen_20250901_0109.diff
+new file mode 100644
+index 0000000..1054e3b
+--- /dev/null
++++ b/diffs/startscreen_20250901_0109.diff
+@@ -0,0 +1,40 @@
++diff --git a/reactShell/src/App.tsx b/reactShell/src/App.tsx
++index 06bb832..7e15bc5 100644
++--- a/reactShell/src/App.tsx
+++++ b/reactShell/src/App.tsx
++@@ -1,11 +1,14 @@
++-import { useEffect } from 'react'
+++import { useEffect, useState } from 'react'
++ import GameCanvas from './game/GameCanvas'
++ import Hud from './ui/Hud'
++ import UpgradeMenu from './ui/UpgradeMenu'
++ import StatusOverlay from './ui/StatusOverlay'
++ import PauseOverlay from './ui/PauseOverlay'
+++import StartScreen from './ui/StartScreen'
++ 
++ function App() {
+++  const [showStart, setShowStart] = useState(true)
+++
++   useEffect(() => {
++     // Initialize game
++     console.log('Asteroids React Shell initializing...')
++@@ -18,6 +21,7 @@ function App() {
++       <UpgradeMenu />
++       <StatusOverlay />
++       <PauseOverlay />
+++      <StartScreen visible={showStart} onDismiss={() => setShowStart(false)} />
++     </div>
++   )
++ }
++diff --git a/reactShell/src/main.tsx b/reactShell/src/main.tsx
++index 651a687..3ccc3d8 100644
++--- a/reactShell/src/main.tsx
+++++ b/reactShell/src/main.tsx
++@@ -2,6 +2,7 @@ import React from 'react'
++ import ReactDOM from 'react-dom/client'
++ import App from './App.tsx'
++ import './index.css'
+++import './styles.css'
++ 
++ ReactDOM.createRoot(document.getElementById('root')!).render(
++   <App />
+diff --git a/docs/prompts/16.md b/docs/prompts/16.md
+new file mode 100644
+index 0000000..b56c196
+--- /dev/null
++++ b/docs/prompts/16.md
+@@ -0,0 +1,44 @@
++EXECUTION MODE — show the vanilla start screen in React. Output one unified diff under `/diffs/` only. Then commit and push.
++
++Goal
++- Render the vanilla `start_screen.png` as a fullscreen overlay above the Three canvas.
++- No gameplay yet; click or press Space hides the overlay (state lives in App).
++
++Scope
++- `/AsteroidsV2/reactShell/src/App.tsx`
++- `/AsteroidsV2/reactShell/src/ui/StartScreen.tsx` (new)
++- `/AsteroidsV2/reactShell/src/styles.css` (append styles if needed)
++
++Requirements
++
++1) StartScreen component (new file)
++- Renders a fullscreen, centered image sourced from `assets/start_screen.png` (match vanilla path/casing).
++- Props: `visible: boolean`, `onDismiss: () => void`.
++- If `visible`, capture click and Space key to call `onDismiss()`.
++- Minimal styles: fixed, inset:0, display:flex, align/justify center, black background.
++
++2) App integration
++- Keep `GameCanvas` mounted behind the overlay.
++- Local state `showStart`, default `true`.
++- Render `<StartScreen visible={showStart} onDismiss={() => setShowStart(false)} />` over the canvas.
++- Ensure z-index so overlay is above canvas.
++
++3) CSS (styles.css)
++- If not already present, ensure:
++  ```css
++  html, body, #root { height: 100%; margin: 0; }
++  canvas { display: block; }
++  .overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; }
++  .overlay img { max-width: 90vw; max-height: 90vh; }
++
++	•	Use the .overlay class in StartScreen.
++
++Constraints
++	•	Do not touch PostFX, GameLoop, or other systems.
++	•	Asset src must be assets/start_screen.png (no renames or moves).
++
++Deliverable
++	•	Print ONE timestamped unified diff under /diffs/ with the full patch (new StartScreen.tsx, edits to App.tsx, any CSS additions). No truncation or summaries.
++
++commit and push
++
+diff --git a/reactShell/src/App.tsx b/reactShell/src/App.tsx
+index 06bb832..7e15bc5 100644
+--- a/reactShell/src/App.tsx
++++ b/reactShell/src/App.tsx
+@@ -1,11 +1,14 @@
+-import { useEffect } from 'react'
++import { useEffect, useState } from 'react'
+ import GameCanvas from './game/GameCanvas'
+ import Hud from './ui/Hud'
+ import UpgradeMenu from './ui/UpgradeMenu'
+ import StatusOverlay from './ui/StatusOverlay'
+ import PauseOverlay from './ui/PauseOverlay'
++import StartScreen from './ui/StartScreen'
+ 
+ function App() {
++  const [showStart, setShowStart] = useState(true)
++
+   useEffect(() => {
+     // Initialize game
+     console.log('Asteroids React Shell initializing...')
+@@ -18,6 +21,7 @@ function App() {
+       <UpgradeMenu />
+       <StatusOverlay />
+       <PauseOverlay />
++      <StartScreen visible={showStart} onDismiss={() => setShowStart(false)} />
+     </div>
+   )
+ }
+diff --git a/reactShell/src/main.tsx b/reactShell/src/main.tsx
+index 651a687..3ccc3d8 100644
+--- a/reactShell/src/main.tsx
++++ b/reactShell/src/main.tsx
+@@ -2,6 +2,7 @@ import React from 'react'
+ import ReactDOM from 'react-dom/client'
+ import App from './App.tsx'
+ import './index.css'
++import './styles.css'
+ 
+ ReactDOM.createRoot(document.getElementById('root')!).render(
+   <App />
+diff --git a/reactShell/src/styles.css b/reactShell/src/styles.css
+new file mode 100644
+index 0000000..f9ee628
+--- /dev/null
++++ b/reactShell/src/styles.css
+@@ -0,0 +1,4 @@
++html, body, #root { height: 100%; margin: 0; }
++canvas { display: block; }
++.overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; z-index: 1000; }
++.overlay img { max-width: 90vw; max-height: 90vh; }
+\ No newline at end of file
+diff --git a/reactShell/src/ui/StartScreen.tsx b/reactShell/src/ui/StartScreen.tsx
+new file mode 100644
+index 0000000..7b05a04
+--- /dev/null
++++ b/reactShell/src/ui/StartScreen.tsx
+@@ -0,0 +1,30 @@
++import { useEffect } from 'react'
++
++interface StartScreenProps {
++  visible: boolean
++  onDismiss: () => void
++}
++
++export default function StartScreen({ visible, onDismiss }: StartScreenProps) {
++  useEffect(() => {
++    if (!visible) return
++
++    const handleKeyDown = (event: KeyboardEvent) => {
++      if (event.code === 'Space') {
++        event.preventDefault()
++        onDismiss()
++      }
++    }
++
++    window.addEventListener('keydown', handleKeyDown)
++    return () => window.removeEventListener('keydown', handleKeyDown)
++  }, [visible, onDismiss])
++
++  if (!visible) return null
++
++  return (
++    <div className="overlay" onClick={onDismiss}>
++      <img src="assets/start_screen.png" alt="Start Screen" />
++    </div>
++  )
++}
+\ No newline at end of file
diff --git a/docs/prompts/17.md b/docs/prompts/17.md
new file mode 100644
index 0000000..448cd19
--- /dev/null
+++ b/docs/prompts/17.md
@@ -0,0 +1,47 @@
+
+EXECUTION MODE — port Ship entity from vanilla into React shell. Output ONE unified diff under `/diffs/` only. Then commit and push.
+
+Scope
+- NEW: `/AsteroidsV2/reactShell/src/game/entities/Ship.ts`
+- NEW: `/AsteroidsV2/reactShell/src/game/Input.ts` (if not already implemented)
+- UPDATE: `/AsteroidsV2/reactShell/src/game/GameCanvas.tsx`
+
+Requirements
+
+1) Input.ts
+- Track keyboard states for thrust (W/ArrowUp), rotate left/right (A/D, ArrowLeft/Right), fire (Space or left click).
+- Track mouse position in screen coords.
+- Export an `InputState` interface and an `Input` class with `update()` and `getState()`.
+
+2) Ship.ts
+- Port constants + behavior from vanilla (`main.js`).
+- Must support: thrust, rotation, world wrapping, spawn at origin, face mouse pointer at all times.
+- Visual: replicate vanilla geometry/material. If vanilla uses `ship.png`, reference from `public/assets/ship/ship.png`.
+- API:
+  ```ts
+  export class Ship {
+    object: THREE.Object3D;
+    constructor(scene: THREE.Scene);
+    setAimWorld(target: THREE.Vector2): void;
+    update(dt: number, input: InputState): void;
+    getPosition(): THREE.Vector2;
+  }
+
+	3.	GameCanvas.tsx
+
+	•	Instantiate Input and Ship.
+	•	Add ship.object to scene.
+	•	In RAF loop:
+	•	Convert mouse screen coords to world coords, call ship.setAimWorld(...).
+	•	Call ship.update(dt, input.getState()).
+	•	Keep PostFX render path unchanged.
+	•	Ship must be visible and respond to input once start screen is dismissed.
+
+Constraints
+	•	Do not implement bullets, asteroids, collisions, or HUD in this diff.
+	•	Strict parity with vanilla Ship controls and feel.
+
+Deliverable
+	•	Print ONE timestamped unified diff under /diffs/ with the new Ship.ts, Input.ts, and GameCanvas.tsx edits. No truncation, no summaries.
+	•	After diff, commit and push.
+
diff --git a/reactShell/src/game/GameCanvas.tsx b/reactShell/src/game/GameCanvas.tsx
index cec45d1..35e05ca 100644
--- a/reactShell/src/game/GameCanvas.tsx
+++ b/reactShell/src/game/GameCanvas.tsx
@@ -2,6 +2,14 @@
 import { useEffect, useRef } from 'react'
 import * as THREE from 'three'
 import { createComposer, resize, render } from './render/PostFX'
+import { Input } from './Input'
+import { Ship } from './entities/Ship'
+
+// World constants (from vanilla)
+const WORLD = {
+  width: 564,
+  height: 498,
+}
 
 export default function GameCanvas() {
   const canvasRef = useRef<HTMLCanvasElement>(null)
@@ -12,15 +20,23 @@ export default function GameCanvas() {
     // Basic Three.js setup - placeholder for full game integration
     const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current })
     const scene = new THREE.Scene()
-    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
+    const camera = new THREE.OrthographicCamera(
+      -WORLD.width/2, WORLD.width/2, 
+      WORLD.height/2, -WORLD.height/2, 
+      0.1, 1000
+    )
     
     renderer.setPixelRatio(window.devicePixelRatio)
     renderer.setSize(window.innerWidth, window.innerHeight)
     
-    // Position camera
+    // Position camera for 2D view
     camera.position.z = 5
     camera.lookAt(0, 0, 0)
     
+    // Initialize game systems
+    const input = new Input()
+    const ship = new Ship(scene)
+    
     // Initialize PostFX with default direct rendering (vanilla parity)
     createComposer(renderer, scene, camera, {
       width: window.innerWidth,
@@ -31,8 +47,6 @@ export default function GameCanvas() {
     const handleResize = () => {
       const width = window.innerWidth
       const height = window.innerHeight
-      camera.aspect = width / height
-      camera.updateProjectionMatrix()
       renderer.setPixelRatio(window.devicePixelRatio)
       resize(width, height)
     }
@@ -40,13 +54,43 @@ export default function GameCanvas() {
     window.addEventListener('resize', handleResize)
     handleResize()
 
-    // Basic render loop - will be replaced by full game loop
+    // Screen to world coordinate conversion
+    const screenToWorld = (screenX: number, screenY: number): THREE.Vector2 => {
+      // Convert screen coords to normalized device coordinates
+      const rect = canvasRef.current!.getBoundingClientRect()
+      const x = ((screenX - rect.left) / rect.width) * 2 - 1
+      const y = -((screenY - rect.top) / rect.height) * 2 + 1
+      
+      // Convert to world coordinates using orthographic camera
+      const worldX = x * WORLD.width / 2
+      const worldY = y * WORLD.height / 2
+      
+      return new THREE.Vector2(worldX, worldY)
+    }
+
+    // Game loop
     let raf = 0
     let last = performance.now()
     const animate = (now: number) => {
       const dt = (now - last) / 1000
       last = now
       
+      // Update input
+      input.update()
+      const inputState = input.getState()
+      
+      // Convert mouse screen coordinates to world coordinates
+      const mouseWorld = screenToWorld(inputState.mouseX, inputState.mouseY)
+      
+      // Update ship
+      ship.setAimWorld(mouseWorld)
+      ship.update(dt, inputState)
+      
+      // Follow ship with camera (simple following)
+      const shipPos = ship.getPosition()
+      camera.position.x = shipPos.x
+      camera.position.y = shipPos.y
+      
       render(dt) // Uses direct rendering by default (vanilla parity)
       raf = requestAnimationFrame(animate)
     }
diff --git a/reactShell/src/game/Input.ts b/reactShell/src/game/Input.ts
index f82454d..91be0d6 100644
--- a/reactShell/src/game/Input.ts
+++ b/reactShell/src/game/Input.ts
@@ -1,2 +1,67 @@
 // Input.ts - Keyboard/mouse handling
-export class Input {}
\ No newline at end of file
+
+export interface InputState {
+  thrust: boolean
+  turnLeft: boolean
+  turnRight: boolean
+  fire: boolean
+  mouseX: number
+  mouseY: number
+}
+
+export class Input {
+  private keys = new Set<string>()
+  private mouseState = { x: 0, y: 0, leftButton: false, rightButton: false }
+
+  constructor() {
+    this.setupEventListeners()
+  }
+
+  private setupEventListeners() {
+    // Keyboard events
+    window.addEventListener('keydown', (e) => {
+      this.keys.add(e.key.toLowerCase())
+      if (e.key === ' ') e.preventDefault()
+    })
+
+    window.addEventListener('keyup', (e) => {
+      this.keys.delete(e.key.toLowerCase())
+    })
+
+    // Mouse events
+    window.addEventListener('mousemove', (e) => {
+      this.mouseState.x = e.clientX
+      this.mouseState.y = e.clientY
+    })
+
+    window.addEventListener('mousedown', (e) => {
+      if (e.button === 0) this.mouseState.leftButton = true
+      if (e.button === 2) this.mouseState.rightButton = true
+    })
+
+    window.addEventListener('mouseup', (e) => {
+      if (e.button === 0) this.mouseState.leftButton = false
+      if (e.button === 2) this.mouseState.rightButton = false
+    })
+
+    // Prevent context menu
+    window.addEventListener('contextmenu', (e) => {
+      e.preventDefault()
+    })
+  }
+
+  update() {
+    // Input updates happen via event listeners, nothing to do here
+  }
+
+  getState(): InputState {
+    return {
+      thrust: this.keys.has('w') || this.keys.has('arrowup') || this.mouseState.rightButton,
+      turnLeft: this.keys.has('a') || this.keys.has('arrowleft'),
+      turnRight: this.keys.has('d') || this.keys.has('arrowright'),
+      fire: this.keys.has(' ') || this.mouseState.leftButton,
+      mouseX: this.mouseState.x,
+      mouseY: this.mouseState.y
+    }
+  }
+}
\ No newline at end of file
diff --git a/reactShell/src/game/entities/Ship.ts b/reactShell/src/game/entities/Ship.ts
index 6dda721..28a2a02 100644
--- a/reactShell/src/game/entities/Ship.ts
+++ b/reactShell/src/game/entities/Ship.ts
@@ -1,2 +1,156 @@
 // Ship.ts - Player ship
-export class Ship {}
\ No newline at end of file
+import * as THREE from 'three'
+import type { InputState } from '../Input'
+
+// Constants from vanilla
+const PLAYER = {
+  accel: 40,
+  maxSpeed: 40,
+  friction: 0.98,
+  turn: 3.2,
+  fireRate: 0.16,
+}
+
+const WORLD = {
+  width: 564,
+  height: 498,
+}
+
+export class Ship {
+  object: THREE.Object3D
+  private velocity = new THREE.Vector2(0, 0)
+  private fireCooldown = 0
+  private minAimDistance = 20 // Minimum distance for mouse aiming
+
+  constructor(scene: THREE.Scene) {
+    this.object = this.createShipMesh()
+    this.object.userData = {
+      kind: 'ship',
+      vx: 0,
+      vy: 0,
+      rot: 0,
+      alive: true,
+      fireCooldown: 0,
+      radius: 1.5
+    }
+    
+    // Start at origin facing left (like vanilla)
+    this.object.position.set(0, 0, 0)
+    this.object.rotation.z = Math.PI // pointing left (flipped around)
+    
+    scene.add(this.object)
+  }
+
+  private createShipMesh(): THREE.Object3D {
+    // Load ship texture
+    const loader = new THREE.TextureLoader()
+    const shipTexture = loader.load('assets/ship/ship.png')
+    
+    // Create ship geometry with texture (same as vanilla)
+    const shipGeometry = new THREE.PlaneGeometry(6.0, 6.0)
+    const shipMaterial = new THREE.MeshBasicMaterial({
+      map: shipTexture,
+      transparent: true,
+      opacity: 1.0,
+      side: THREE.DoubleSide
+    })
+    
+    return new THREE.Mesh(shipGeometry, shipMaterial)
+  }
+
+  setAimWorld(target: THREE.Vector2): void {
+    const dx = target.x - this.object.position.x
+    const dy = target.y - this.object.position.y
+    const distance = Math.hypot(dx, dy)
+    
+    // Only update rotation if mouse is not too close to ship (vanilla behavior)
+    if (distance > this.minAimDistance) {
+      const angle = Math.atan2(dy, dx)
+      this.object.rotation.z = angle + Math.PI/2 // Adjust for mesh facing up by default, flipped around
+    }
+  }
+
+  update(dt: number, input: InputState): void {
+    const s = this.object.userData
+
+    // Handle manual turning when not using mouse aim
+    if (input.turnLeft && !this.isMouseAimActive(input)) {
+      this.object.rotation.z += PLAYER.turn * dt
+    }
+    if (input.turnRight && !this.isMouseAimActive(input)) {
+      this.object.rotation.z -= PLAYER.turn * dt
+    }
+
+    // Thrust mechanics
+    if (input.thrust) {
+      // Ship mesh faces up, rotation.z is already the direction to move
+      const shipDirection = this.object.rotation.z + Math.PI/2 // Convert ship rotation to movement direction
+      const ax = Math.cos(shipDirection) * PLAYER.accel * dt
+      const ay = Math.sin(shipDirection) * PLAYER.accel * dt
+      
+      s.vx += ax
+      s.vy += ay
+      this.velocity.set(s.vx, s.vy)
+    }
+
+    // Apply speed limits and friction
+    const speed = this.velocity.length()
+    if (speed > PLAYER.maxSpeed) {
+      this.velocity.normalize().multiplyScalar(PLAYER.maxSpeed)
+      s.vx = this.velocity.x
+      s.vy = this.velocity.y
+    }
+
+    s.vx *= PLAYER.friction
+    s.vy *= PLAYER.friction
+    this.velocity.set(s.vx, s.vy)
+
+    // Update position
+    this.object.position.x += s.vx * dt
+    this.object.position.y += s.vy * dt
+
+    // World wrapping
+    this.wrap()
+
+    // Fire cooldown
+    this.fireCooldown = Math.max(0, this.fireCooldown - dt)
+    s.fireCooldown = this.fireCooldown
+  }
+
+  private isMouseAimActive(input: InputState): boolean {
+    // For now, always use mouse aim (vanilla behavior)
+    // Later this could be toggled based on game state
+    return true
+  }
+
+  private wrap(): void {
+    const halfWidth = WORLD.width / 2
+    const halfHeight = WORLD.height / 2
+    
+    if (this.object.position.x > halfWidth) {
+      this.object.position.x = -halfWidth
+    } else if (this.object.position.x < -halfWidth) {
+      this.object.position.x = halfWidth
+    }
+    
+    if (this.object.position.y > halfHeight) {
+      this.object.position.y = -halfHeight
+    } else if (this.object.position.y < -halfHeight) {
+      this.object.position.y = halfHeight
+    }
+  }
+
+  getPosition(): THREE.Vector2 {
+    return new THREE.Vector2(this.object.position.x, this.object.position.y)
+  }
+
+  // Utility method for firing (will be used later)
+  canFire(): boolean {
+    return this.fireCooldown <= 0
+  }
+
+  // Set fire cooldown after shooting
+  setFireCooldown(): void {
+    this.fireCooldown = PLAYER.fireRate
+  }
+}
\ No newline at end of file
