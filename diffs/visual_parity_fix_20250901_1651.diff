diff --git a/reactShell/src/game/GameCanvas.tsx b/reactShell/src/game/GameCanvas.tsx
index 227e1e7..302854b 100644
--- a/reactShell/src/game/GameCanvas.tsx
+++ b/reactShell/src/game/GameCanvas.tsx
@@ -14,6 +14,7 @@ import { GameState, selectScore, selectWave, selectCombo, selectCurrency, select
 import { createEnemyBullets } from './systems/EnemyBullets'
 import { DevStats } from '../ui/DevPanel'
 import { DebugBus } from '../dev/DebugBus'
+import { VISIBLE_HEIGHT, getVisibleWidth, pxToWorld, worldToPx } from '../utils/units'
 
 // HUD data type for passing game state to UI
 export interface HudData {
@@ -41,9 +42,11 @@ const WORLD = {
   height: 498,
 }
 
-// Pixel-perfect orthographic camera mapping
-function makeOrthoCamera(w: number, h: number): THREE.OrthographicCamera {
-  const halfW = w / 2, halfH = h / 2
+// World-unit based orthographic camera (vanilla parity)
+function makeOrthoCamera(aspect: number): THREE.OrthographicCamera {
+  const visibleWidth = getVisibleWidth(aspect)
+  const halfW = visibleWidth / 2
+  const halfH = VISIBLE_HEIGHT / 2
   const cam = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, 0.1, 1000)
   cam.position.set(0, 0, 10)
   cam.lookAt(0, 0, 0)
@@ -79,7 +82,7 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
     // Basic Three.js setup - placeholder for full game integration
     const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current })
     const scene = new THREE.Scene()
-    const camera = makeOrthoCamera(window.innerWidth, window.innerHeight)
+    const camera = makeOrthoCamera(window.innerWidth / window.innerHeight)
     
     renderer.setPixelRatio(window.devicePixelRatio)
     renderer.setSize(window.innerWidth, window.innerHeight)
@@ -132,10 +135,13 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
     const handleResize = () => {
       const width = window.innerWidth
       const height = window.innerHeight
+      const aspect = width / height
       renderer.setPixelRatio(window.devicePixelRatio)
       
-      // Update camera frustum to match new canvas size
-      const halfW = width / 2, halfH = height / 2
+      // Update camera to maintain world-unit scale
+      const visibleWidth = getVisibleWidth(aspect)
+      const halfW = visibleWidth / 2
+      const halfH = VISIBLE_HEIGHT / 2
       camera.left = -halfW
       camera.right = halfW
       camera.top = halfH
@@ -148,12 +154,18 @@ export default function GameCanvas({ onStats, onHudData, onMiniSnapshot, onGameS
     window.addEventListener('resize', handleResize)
     handleResize()
 
-    // Screen to world coordinate conversion (1:1 pixel mapping)
+    // Screen to world coordinate conversion (world-unit based)
     const screenToWorld = (screenX: number, screenY: number): THREE.Vector2 => {
       const rect = canvasRef.current!.getBoundingClientRect()
-      // Convert to world coordinates (1 world unit = 1 CSS pixel)
-      const worldX = screenX - rect.left - rect.width / 2
-      const worldY = -(screenY - rect.top - rect.height / 2)
+      const aspect = rect.width / rect.height
+      const visibleWidth = getVisibleWidth(aspect)
+      
+      // Convert screen pixels to world coordinates
+      const normalizedX = (screenX - rect.left - rect.width / 2) / (rect.width / 2)
+      const normalizedY = -((screenY - rect.top - rect.height / 2) / (rect.height / 2))
+      
+      const worldX = normalizedX * (visibleWidth / 2)
+      const worldY = normalizedY * (VISIBLE_HEIGHT / 2)
       
       return new THREE.Vector2(worldX, worldY)
     }
diff --git a/reactShell/src/game/GameState.ts b/reactShell/src/game/GameState.ts
index 0b09d30..af212b1 100644
--- a/reactShell/src/game/GameState.ts
+++ b/reactShell/src/game/GameState.ts
@@ -56,7 +56,7 @@ export class GameState {
     spread: 0,
     pierce: 0,
     ricochet: 0,
-    shieldCharges: 3,  // Start with 3 shield charges for testing
+    shieldCharges: 0,  // Start with no shields (acquired through upgrades)
     bulletBounce: 0,
     bulletLifeMul: 1.0,
     bulletSpeedMul: 1.0,
@@ -179,7 +179,7 @@ export class GameState {
       spread: 0,
       pierce: 0,
       ricochet: 0,
-      shieldCharges: 3,  // Start with 3 shield charges for testing
+      shieldCharges: 0,  // Start with no shields (acquired through upgrades)
       bulletBounce: 0,
       bulletLifeMul: 1.0,
       bulletSpeedMul: 1.0,
diff --git a/reactShell/src/game/entities/Asteroid.ts b/reactShell/src/game/entities/Asteroid.ts
index cc6a209..014500d 100644
--- a/reactShell/src/game/entities/Asteroid.ts
+++ b/reactShell/src/game/entities/Asteroid.ts
@@ -1,5 +1,6 @@
 // Asteroid.ts - Asteroid variants
 import * as THREE from 'three'
+import { WORLD_BOUNDS } from '../utils/units'
 
 // Constants from vanilla (lines 28-33)
 const ASTEROIDS = {
@@ -9,10 +10,6 @@ const ASTEROIDS = {
   baseSpeed: 8,
 }
 
-const WORLD = {
-  width: 750,
-  height: 498,
-}
 
 // Ore types with colors and probabilities (from lines 819-825)
 export type OreType = 'iron' | 'gold' | 'platinum' | 'adamantium'
@@ -87,10 +84,12 @@ export class Asteroid {
     outlineMesh.position.z = -0.01 // Place behind main disk
     group.add(outlineMesh)
     
-    // Create main asteroid disk
+    // Create main asteroid disk with enhanced brightness
     const geometry = new THREE.CircleGeometry(radius, 16)
+    const baseColor = ORE_COLORS[this.oreType]
     const material = new THREE.MeshBasicMaterial({ 
-      color: ORE_COLORS[this.oreType],
+      // Enhanced brightness instead of emissive (not supported by MeshBasicMaterial)
+      color: new THREE.Color(baseColor).multiplyScalar(1.2), // Brighter color
       transparent: false
     })
     const mainMesh = new THREE.Mesh(geometry, material)
@@ -106,20 +105,17 @@ export class Asteroid {
     this.object.position.x += this.velocity.x * dt
     this.object.position.y += this.velocity.y * dt
     
-    // World wrapping at ±375×±249
-    const halfWidth = WORLD.width / 2  // ±375
-    const halfHeight = WORLD.height / 2 // ±249
-    
-    if (this.object.position.x > halfWidth) {
-      this.object.position.x = -halfWidth
-    } else if (this.object.position.x < -halfWidth) {
-      this.object.position.x = halfWidth
+    // World wrapping at world bounds
+    if (this.object.position.x > WORLD_BOUNDS.x) {
+      this.object.position.x = -WORLD_BOUNDS.x
+    } else if (this.object.position.x < -WORLD_BOUNDS.x) {
+      this.object.position.x = WORLD_BOUNDS.x
     }
     
-    if (this.object.position.y > halfHeight) {
-      this.object.position.y = -halfHeight
-    } else if (this.object.position.y < -halfHeight) {
-      this.object.position.y = halfHeight
+    if (this.object.position.y > WORLD_BOUNDS.y) {
+      this.object.position.y = -WORLD_BOUNDS.y
+    } else if (this.object.position.y < -WORLD_BOUNDS.y) {
+      this.object.position.y = WORLD_BOUNDS.y
     }
     
     // Rotation
diff --git a/reactShell/src/game/entities/Bullet.ts b/reactShell/src/game/entities/Bullet.ts
index 85cce11..434cda8 100644
--- a/reactShell/src/game/entities/Bullet.ts
+++ b/reactShell/src/game/entities/Bullet.ts
@@ -1,5 +1,6 @@
 // Bullet.ts - Projectile system
 import * as THREE from 'three'
+import { pxToWorld, WORLD_BOUNDS } from '../utils/units'
 
 // Constants from vanilla
 const BULLET = { 
@@ -8,10 +9,8 @@ const BULLET = {
   r: 0.2 
 }
 
-const WORLD = {
-  width: 750,
-  height: 498,
-}
+// Default bullet visual size in pixels
+const DEFAULT_BULLET_PX = 3
 
 export class Bullet {
   mesh: THREE.Mesh
@@ -22,12 +21,12 @@ export class Bullet {
   public isEnemy = false
 
   constructor() {
-    // Create brighter, more visible bullet visual
-    // Use slightly larger visual size (2-3px equivalent) while keeping collision radius unchanged
-    const visualRadius = 1.0 // Larger visual size for better visibility
+    // Create brighter, more visible bullet visual with world-unit scaling
+    // Convert target pixel size to world units (using window height as reference)
+    const visualRadius = pxToWorld(DEFAULT_BULLET_PX, window.innerHeight)
     const geometry = new THREE.SphereGeometry(visualRadius, 8, 6)
     const material = new THREE.MeshBasicMaterial({ 
-      color: 0xE6E6E6 // Brighter than pure white for better visibility on dark backgrounds
+      color: 0xE6E6E6, // Brighter than pure white for better visibility
     })
     this.mesh = new THREE.Mesh(geometry, material)
     this.mesh.userData = {
@@ -64,19 +63,16 @@ export class Bullet {
   }
 
   private wrap(): void {
-    const halfWidth = WORLD.width / 2  // ±375
-    const halfHeight = WORLD.height / 2 // ±249
-    
-    if (this.mesh.position.x > halfWidth) {
-      this.mesh.position.x = -halfWidth
-    } else if (this.mesh.position.x < -halfWidth) {
-      this.mesh.position.x = halfWidth
+    if (this.mesh.position.x > WORLD_BOUNDS.x) {
+      this.mesh.position.x = -WORLD_BOUNDS.x
+    } else if (this.mesh.position.x < -WORLD_BOUNDS.x) {
+      this.mesh.position.x = WORLD_BOUNDS.x
     }
     
-    if (this.mesh.position.y > halfHeight) {
-      this.mesh.position.y = -halfHeight
-    } else if (this.mesh.position.y < -halfHeight) {
-      this.mesh.position.y = halfHeight
+    if (this.mesh.position.y > WORLD_BOUNDS.y) {
+      this.mesh.position.y = -WORLD_BOUNDS.y
+    } else if (this.mesh.position.y < -WORLD_BOUNDS.y) {
+      this.mesh.position.y = WORLD_BOUNDS.y
     }
   }
 
diff --git a/reactShell/src/game/entities/Ship.ts b/reactShell/src/game/entities/Ship.ts
index 7ccf23e..ca7b017 100644
--- a/reactShell/src/game/entities/Ship.ts
+++ b/reactShell/src/game/entities/Ship.ts
@@ -3,6 +3,7 @@ import * as THREE from 'three'
 import type { InputState } from '../Input'
 import type { BulletManager } from '../systems/BulletManager'
 import type { GameState } from '../GameState'
+import { pxToWorld, WORLD_BOUNDS } from '../utils/units'
 
 // Constants from vanilla
 const PLAYER = {
@@ -18,13 +19,9 @@ const INVULN_WAVE = 3.0   // At wave start
 const INVULN_SPAWN = 2.0  // After respawn
 const INVULN_HIT = 1.0    // After taking damage
 
-const WORLD = {
-  width: 750,
-  height: 498,
-}
 
 // Ship visual scale
-const SHIP_DESIRED_PX = 50 // tweak 90–110 for parity with vanilla screenshot
+const SHIP_DESIRED_PX = 50 // Target 50px height on screen
 const ROTATION_OFFSET = -Math.PI / 2 // Ship sprite nose points "up" (+Y)
 
 export class Ship {
@@ -74,13 +71,16 @@ export class Ship {
       texture.minFilter = THREE.NearestFilter
       texture.generateMipmaps = false
       
-      // Scale ship to desired pixel height once texture is loaded
+      // Scale ship to world units based on target pixel height
       const imgH = texture.image?.height ?? SHIP_DESIRED_PX
       const imgW = texture.image?.width ?? SHIP_DESIRED_PX
-      const scale = SHIP_DESIRED_PX / imgH
+      const aspectRatio = imgW / imgH
+      
+      // Convert target pixel height to world units (using window height as reference)
+      const targetWorldHeight = pxToWorld(SHIP_DESIRED_PX, window.innerHeight)
       
-      // Scale the mesh to achieve desired on-screen size
-      this.object.scale.set(imgW * scale, SHIP_DESIRED_PX, 1)
+      // Scale the mesh to achieve desired world size
+      this.object.scale.set(targetWorldHeight * aspectRatio, targetWorldHeight, 1)
     })
     
     // Create ship geometry with texture (placeholder size will be scaled)
@@ -97,8 +97,9 @@ export class Ship {
   }
 
   private createShieldVisual(): void {
-    // Create transparent sphere around ship for shield visual
-    const shieldGeometry = new THREE.SphereGeometry(35, 16, 12) // Slightly larger than ship
+    // Create transparent sphere around ship for shield visual (world units)
+    const shieldRadius = 3.5 // World units, roughly ship size + buffer
+    const shieldGeometry = new THREE.SphereGeometry(shieldRadius, 16, 12)
     const shieldMaterial = new THREE.MeshBasicMaterial({
       color: 0x00ffff,
       transparent: true,
@@ -203,19 +204,16 @@ export class Ship {
   }
 
   private wrap(): void {
-    const halfWidth = WORLD.width / 2
-    const halfHeight = WORLD.height / 2
-    
-    if (this.object.position.x > halfWidth) {
-      this.object.position.x = -halfWidth
-    } else if (this.object.position.x < -halfWidth) {
-      this.object.position.x = halfWidth
+    if (this.object.position.x > WORLD_BOUNDS.x) {
+      this.object.position.x = -WORLD_BOUNDS.x
+    } else if (this.object.position.x < -WORLD_BOUNDS.x) {
+      this.object.position.x = WORLD_BOUNDS.x
     }
     
-    if (this.object.position.y > halfHeight) {
-      this.object.position.y = -halfHeight
-    } else if (this.object.position.y < -halfHeight) {
-      this.object.position.y = halfHeight
+    if (this.object.position.y > WORLD_BOUNDS.y) {
+      this.object.position.y = -WORLD_BOUNDS.y
+    } else if (this.object.position.y < -WORLD_BOUNDS.y) {
+      this.object.position.y = WORLD_BOUNDS.y
     }
   }
 
@@ -233,18 +231,19 @@ export class Ship {
     this.fireCooldown = PLAYER.fireRate
   }
 
-  // Set ship pixel height for runtime tuning
-  setPixelHeight(px: number): void {
-    // Reapply texture scaling using the same logic as createShipMesh
+  // Set ship pixel height for runtime tuning (converts to world units)
+  setPixelHeight(px: number, viewportHeight: number): void {
+    const targetWorldHeight = pxToWorld(px, viewportHeight)
+    
     const material = (this.object as THREE.Mesh).material as THREE.MeshBasicMaterial
     if (material.map && material.map.image) {
       const texture = material.map
       const imgH = texture.image.height
       const imgW = texture.image.width
-      const scale = px / imgH
+      const aspectRatio = imgW / imgH
       
-      // Scale the mesh to achieve desired on-screen size
-      this.object.scale.set(imgW * scale, px, 1)
+      // Scale to target world height, maintaining aspect ratio
+      this.object.scale.set(targetWorldHeight * aspectRatio, targetWorldHeight, 1)
     }
   }
 
diff --git a/reactShell/src/utils/units.ts b/reactShell/src/utils/units.ts
new file mode 100644
index 0000000..50176b8
--- /dev/null
+++ b/reactShell/src/utils/units.ts
@@ -0,0 +1,28 @@
+// units.ts - World unit to pixel conversion utilities
+
+// Vanilla world constants
+export const WORLD_WIDTH = 750
+export const WORLD_HEIGHT = 498
+export const VISIBLE_HEIGHT = 99.6 // Visible world units vertically (1/5 of world height)
+
+// Conversion utilities for maintaining visual parity
+export function pxToWorld(px: number, viewportHeight: number): number {
+  // Convert desired pixel size to world units based on current viewport
+  return (px * VISIBLE_HEIGHT) / viewportHeight
+}
+
+export function worldToPx(units: number, viewportHeight: number): number {
+  // Convert world units to pixel size based on current viewport
+  return (units * viewportHeight) / VISIBLE_HEIGHT
+}
+
+// Helper to get visible width based on aspect ratio
+export function getVisibleWidth(aspectRatio: number): number {
+  return VISIBLE_HEIGHT * aspectRatio
+}
+
+// World wrapping boundaries
+export const WORLD_BOUNDS = {
+  x: WORLD_WIDTH / 2,  // ±375
+  y: WORLD_HEIGHT / 2, // ±249
+}
\ No newline at end of file
